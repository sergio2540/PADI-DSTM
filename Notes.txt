Notas para esperar por transacções na leitura:
->Se lermos um objecto que foi escrito, temos de esperar que a outra termine e faca commit para ler depois esse valor, para que nao hajam dirty reads. Convem que o object saiba quando
e que o outro terminou, ou quando não tem ninguém antes dele:

Abordagens:
->Verificar se há objectos tentativa antes deste. Se não houverem, chama funcao de escrita.
->poderiamos por o objecto antes do que quer fazer commit a notificá-lo caso aborte ou faça commit.
->Poderiamos ter um gestor de transaccoes pendentes.
->Podiamos parar a thread 


Duvidas:
->A transaction’s read operation is directed to the version with the maximum write timestamp less than the transaction timestamp.
->If transaction Tc has already written its own version of the object, this will be used.



Abordagem usada:
As threads esperam no read. Quando uma thread faz commit, a thread é notificada para continuar.


class TransactionalManager{
private static EventWaitHandle readWait = new EventWaitHandle(false, EventResetMode.AutoReset);

if(espera){
	
	readWait.WaitOne();

	//chamada recursiva a Read. Tem de testar tudo de novo. São desbloqueadas por ordem?
	//deveria ser assinalada pelo doCommit que está na mesma classe usando Set()
	Read(tid,uid);
	

}


}

->Podem haver diversas threads à espera para ler diferentes objectos. Deviamos libertar handles consoante o uid.

O read deve permitir leitura durante todo o tempo em que não há writes anteriores a esse read. O ideal deveria ser:
->A cada write, bloquear o fluxo de threads pois todas as que quiserem ler esse objecto, teem de ficar bloqueadas se vierem antes;
O ideal deveria ser, haver um reset a cada write e um set a cada do commit.


doCommit e doAbort:
->quando faço can commit, tenho de esperar por outras transacções terminarem para verificar se podem fazer commit. convinha que
caso houvessem transaccoes que têem objectos tentativa, a transacção espere. se houverem objectos tentativa com timestamp inferior,
deve esperar-se por elas.

Faz sentido libertar as threads todas ao mesmo tempo?
No can commit, se houvessem, bloqueavam numa fila que bloqueia por identificador de objecto.
No do commit ou abort, libertávamos transacções pendentes por objecto.
O reset deveria ser feito quando ha writes num dado objecto. Isto é semelhante ao read.






Temos de peor o access como access e nao como read.
Idealmente, as transaccoes commited e aborted deveriam sair da lista de modificados.
Ter em atencao que o read, vai ver se os que lá estão estão commited. seria mais inteligente ele, quando tivesse permissão para avancar e se nao tivesse ninguém na lista
de alterados ler logo o commited.





Se escrever, trava commits porque as outras teem de esperar. Mas se um escreve e bloqueia depois nao pode fazer commit a sua transacaccao. deadlock.


Se houver apenas um, desbloqueia-se entradas
Se houverem varios, espera-se que uma faça commit ou abort para que as outras avancem. 